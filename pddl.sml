structure PDDL = struct

datatype fluent = Fluent of { name : string, arguments : string list }
fun compareFluents (Fluent {name = na, arguments = aa},
                    Fluent {name = nb, arguments = ab}) =
    case String.compare (na, nb) of
        EQUAL => List.collate String.compare (aa, ab)
      | v => v

structure FluentSet = ListSetFn(struct type ord_key = fluent val compare = compareFluents end)
structure StringMap = ListMapFn(struct type ord_key = string val compare = String.compare end)
type state = FluentSet.set
type binding = string StringMap.map

datatype pred_arg = Literal of string | Variable of string
datatype predicate =      Predicate of { truth          : bool,
                                         name           : string,
                                         arguments      : pred_arg list }

datatype action =            Action of { name           : string,
                                         variables      : string list,
                                         used_variables : string list,
                                         preconditions  : predicate list,
                                         effects        : predicate list }
datatype action_instance = Instance of { bindings       : binding,
                                         action         : action }

datatype problem =          Problem of { actions        : action list,
                                         objects        : string list,
                                         start          : state,
                                         (* INVARIANT: There are no variables in goal *)
                                         goal           : predicate list }

(* Name: bindPredicate binding pred *)
(* Type: binding -> predicate -> fluent *)
(* Pre:  All variables in pred are bound in binding *)
(* Note: The truth values of pred is discarded. *)
fun bindPredicate binding (Predicate {name, arguments, ...}) =
    let
        fun bindArg (Literal  v) = v
          | bindArg (Variable n) =
            case StringMap.find (binding, n) of
                SOME v => v
              | NONE => raise Fail ("Unbound variable " ^ name ^ "(..., " ^ n ^ ", ...) in PDDL.bindPredicate")
    in
        Fluent { name = name, arguments = map bindArg arguments }
    end

(* Type: binding -> predicate list -> FluentSet.set *)
(* Pre: All variables in preds are bound in binding *)
(* Note: The truth values of the predicates are discarded. *)
fun bind binding preds = FluentSet.addList (FluentSet.empty, map (bindPredicate binding) preds)

(* Name: applyAction state instance *)
(* Type: state -> action_instance -> state *)
(* Post: The new state generated by performing instance in state state *)
fun applyAction state (Instance {bindings, action = Action{effects,...}}) =
    let
        fun truth (Predicate {truth, ...}) = truth
        val (truePreds, falsePreds) = List.partition truth effects
        val add    = bind bindings truePreds
        val remove = bind bindings falsePreds
        val state = FluentSet.difference(state,remove)
    in
        FluentSet.union(state,add)
    end


(* Type: predicate list -> binding -> state -> bool *)
(* Pre:  All variables in preds are bound in binding *)
(* Post: Whether state matches the predicates preds instantiated with bindings binding *)
fun matchesPredicates preds binding state =
    let
        fun truth (Predicate {truth,...}) = truth
        val (truePreds, falsePreds) = List.partition truth preds
        val required  = bind binding truePreds
        val forbidden = bind binding falsePreds
    in
        FluentSet.isEmpty (FluentSet.difference   (required,  state)) andalso
        FluentSet.isEmpty (FluentSet.intersection (forbidden, state))
    end

(* Type: problem -> state -> bool *)
fun isGoal (Problem {goal, ...}) state = matchesPredicates goal StringMap.empty state

(* Type: string -> FluentSet.set -> fluent list *)
fun getFluentsByName name state =
    FluentSet.listItems (FluentSet.filter (fn Fluent {name=flun,...} => flun = name) state)

fun getFluentsMatchingPattern (n, pattern) state =
    let
        fun matchPattern (nil, nil) = true
          | matchPattern (NONE::ps, _::ss) = matchPattern (ps, ss)
          | matchPattern ((SOME pv)::ps, sv::ss) =
            pv = sv andalso matchPattern (ps, ss)
          | matchPattern _ = raise Fail "Argument count mismatch in PDDL.getFluentsMatchingPattern"
    in
        (FluentSet.filter (fn Fluent {name, arguments} => name = n andalso matchPattern (pattern, arguments))
                          state) |>
        FluentSet.listItems
    end

(* Name: satisfyingBindings problem state predicates binding *)
(* Type: problem -> state -> predicate list -> binding -> binding list *)
(* Post: All bindings that are supersets of binding and satisfy predicates in state,
         a variable left unbound implies it may take an arbitrary binding and still satisfy predicates *)
fun satisfyingBindings _ _ ([] : predicate list) (bindings : binding) = [ bindings ] : binding list
  | satisfyingBindings (problem as Problem {objects, ...}) (state : state)
                       ((Predicate {truth, name, arguments}) :: preds) bindings =
    let
        val pattern = map (fn Literal l  => SOME l
                            | Variable v => StringMap.find (bindings, v)) arguments
        val fluentArgs = map (fn Fluent {arguments,...} => arguments)
                             (getFluentsMatchingPattern (name, pattern) state)
        fun takeEqual v (l::ls) =
            if v = l then SOME ls
            else          NONE
          | takeEqual _ [] =
            raise Fail ("Unexpected end of list in PDDL.satisfyingBindings.takeEqual. " ^
                        "Possibly mismatched number of arguments.")

        (* All bindings that make Predicate match at least one of fluentArgs. *)
        (* fluentArgs are the arguments of the fluents of the same name *)
        fun trueBinds _        []         _  = []
          | trueBinds bindings fluentArgs [] = [ bindings ]
          | trueBinds bindings fluentArgs (Literal  v :: args) =
            (* We have already prefiltered non-matching literals above *)
            trueBinds bindings fluentArgs args
          | trueBinds bindings fluentArgs (Variable n :: args) =
            case StringMap.find (bindings, n) of
                SOME v => trueBinds bindings (List.mapPartial (takeEqual v) fluentArgs) args
              | NONE =>
                let
                    val uniqueValues = ListMergeSort.uniqueSort String.compare
                                                                (map hd fluentArgs)
                in
                    mapConcat (fn v => trueBinds (StringMap.insert (bindings, n, v))
                                                 (List.mapPartial (takeEqual v) fluentArgs)
                                                 args)
                              uniqueValues
                end

        (* All bindings that make Predicate match none of fluentArgs. *)
        fun falseBinds bindings [] args = [ bindings ]
          | falseBinds bindings _  []   = []
          | falseBinds bindings fluentArgs (Literal v :: args) =
            falseBinds bindings (List.mapPartial (takeEqual v) fluentArgs) args
          | falseBinds bindings fluentArgs (Variable n :: args) =
            case StringMap.find (bindings, n) of
                SOME v => falseBinds bindings (List.mapPartial (takeEqual v) fluentArgs) args
              | NONE => mapConcat (fn v => falseBinds (StringMap.insert (bindings, n, v))
                                                      (List.mapPartial (takeEqual v) fluentArgs)
                                                      args)
                                  objects
    in
        (* Note: |> is the pipelining operator, defined in utilities.sml *)
        (if truth then trueBinds else falseBinds) bindings fluentArgs arguments |>
        mapConcat (satisfyingBindings problem state preds)
    end

(* Type: problem -> state -> action_instance list *)
fun possibleActions (problem as Problem {actions, objects,...}) state =
    let
        fun allInstances (action as Action {preconditions, used_variables, ...}) =
            let
                (* Note: This is a source of combinatorial explosion. If
                   we allow a variable to be unbound when it may
                   be arbitrary, we can avoid this. *)
                fun arbitraryBinds [] bindings = [bindings]
                  | arbitraryBinds (n :: args) bindings =
                    case StringMap.find (bindings, n) of
                        SOME _ => arbitraryBinds args bindings
                      | NONE   => mapConcat (fn v => arbitraryBinds args (StringMap.insert (bindings, n, v)))
                                            objects

                val (truePres, falsePres) = List.partition (fn Predicate {truth,...} => truth) preconditions
                val allTrueBindings = satisfyingBindings problem state truePres StringMap.empty
                val allBindings = mapConcat (arbitraryBinds used_variables)
                                            (mapConcat (satisfyingBindings problem state falsePres)
                                                       allTrueBindings)
            in
                map (fn binding => Instance { bindings = binding, action = action }) allBindings
            end
    in
        mapConcat allInstances actions
    end
end
